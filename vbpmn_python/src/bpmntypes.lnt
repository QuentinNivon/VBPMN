
(* BPMN data types (FACS'16), necessary for encoding unbalanced workflows
Author: Gwen Salaun *)

module bpmntypes(id) with "get" is

(* set of identifiers *)

type IDS is
    set of ID 
with "==", "!="
end type

(* s of type IDS is a set, so does not store twice the same value *)
function add (v: ID, s: IDS): IDS is
  case s in
  var hd: ID, tl: IDS in
      nil -> return cons(v,nil)
    | cons(hd,tl) -> if (v==hd) then return tl else return cons(hd,add(v,tl)) end if
  end case
end function

function remove (v: ID, s: IDS): IDS is
  case s in
  var hd: ID, tl: IDS in
      nil -> return nil
    | cons(hd,tl) -> if (v==hd) then return tl else return cons(hd,remove(v,tl)) end if
  end case
end function

(* flow *)

type FLOW is
    flow ( ident: ID, source: ID, target: ID )
end type

(* set of flows *) 

type FLOWS is
    set of FLOW
end type

(* task *) 

type TASK is 
    task ( ident: ID, incf: IDS, outf: IDS )
end type

(* set of tasks *)

type TASKS is
    set of TASK
end type

(* initial event *)

type INITIAL is 
    initial ( ident: ID, outf: ID )   (* several outgoing flows (?) *)
end type

(* final event *)

type FINAL is 
    final ( ident: ID, incf: IDS )     (* several incoming flows (?) *)
end type

(* set of final events *)

type FINALS is
    set of FINAL
end type

(* type of gateway *) 

type GSORT is 
    xor, and, or
end type

(* gateway pattern *)

type GPATTERN is 
    split, merge
end type

(* gateway *)

type GATEWAY is
    gateway ( ident: ID, pattern: GPATTERN, sort: GSORT, incf: IDS, outf: IDS )
end type

(* set of gateways *)

type GATEWAYS is
    set of GATEWAY
end type

(* node *)

type NODE is    (* could it be simpler ? *)
    i ( initial: INITIAL ), 
    f ( finals: FINALS ),
    g ( gateways: GATEWAYS ),
    t ( tasks: TASKS )
end type

(* set of nodes *)

type NODES is
    set of NODE
end type

(* bpmn process *)

type BPROCESS is
    proc ( name: ID, nodes: NODES, flows: FLOWS )  (* not the most optimized encoding for traversals *)
end type

function is_merge_possible(process:BPROCESS, activeflows:IDS, mergeid:ID): Nat is 
	var incf:IDS, active_merge:Nat in
        incf := find_incf(process, mergeid);
        active_merge := find_active_tokens(activeflows, incf);
        return active_merge
    end var
end function

function find_incf(process:BPROCESS, mergeid:ID): IDS is 
	var incf:IDS, gateway:GATEWAY in
    case mergeid in
         process(any ID, NODE(any ID, ) , any FLOWS) -> gateway :=node 
        |any -> gateway := null;
    end case;
    case gateway in 
        gateway(any ID, merge, inclusive, inflows: IDS, any IDS ) -> incf = inflows
        |null ->
        |any -> incf = null;
    end case;
    return IDSl
    end var
end function

function find_active_tokens(activeflows:IDS, incf:IDS): Nat is 
	var tokens:IDS, count:Nat in
        tokens := inter(activeflows, incf);
        count := tokens.length()
        return count 
    end var
end function

end module