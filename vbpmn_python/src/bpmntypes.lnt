
(* BPMN data types (FACS'16), necessary for encoding unbalanced workflows
Author: Gwen Salaun *)

module bpmntypes(id) with "get" is

(* set of identifiers *)

type IDS is
    set of ID 
with "==", "!=", "inter", "length"
end type

(* s of type IDS is a set, so does not store twice the same value *)
function add (v: ID, s: IDS): IDS is
  case s in
  var hd: ID, tl: IDS in
      nil -> return cons(v,nil)
    | cons(hd,tl) -> if (v==hd) then return tl else return cons(hd,add(v,tl)) end if
  end case
end function

function remove (v: ID, s: IDS): IDS is
  case s in
  var hd: ID, tl: IDS in
      nil -> return nil
    | cons(hd,tl) -> if (v==hd) then return tl else return cons(hd,remove(v,tl)) end if
  end case
end function

(* flow *)

type FLOW is
    flow ( ident: ID, source: ID, target: ID )
end type

(* set of flows *) 

type FLOWS is
    set of FLOW
end type

(* task *) 

type TASK is 
    task ( ident: ID, incf: IDS, outf: IDS )
end type

(* set of tasks *)

type TASKS is
    set of TASK
end type

(* initial event *)

type INITIAL is 
    initial ( ident: ID, outf: ID )   (* several outgoing flows (?) *)
end type

(* final event *)

type FINAL is 
    final ( ident: ID, incf: IDS )     (* several incoming flows (?) *)
end type

(* set of final events *)

type FINALS is
    set of FINAL
end type

(* type of gateway *) 

type GSORT is 
    xor, and, or
end type

(* gateway pattern *)

type GPATTERN is 
    split, merge
end type

(* gateway *)

type GATEWAY is
    gateway ( ident: ID, pattern: GPATTERN, sort: GSORT, incf: IDS, outf: IDS )
end type

(* set of gateways *)

type GATEWAYS is
    set of GATEWAY
end type

(* node *)

type NODE is    (* could it be simpler ? *)
    i ( initial: INITIAL ), 
    f ( finals: FINALS ),
    g ( gateways: GATEWAYS ),
    t ( tasks: TASKS )
end type

(* set of nodes *)

type NODES is
    set of NODE
end type

(* bpmn process *)

type BPROCESS is
    proc ( name: ID, nodes: NODES, flows: FLOWS )  (* not the most optimized encoding for traversals *)
end type

function is_merge_possible(p: BPROCESS, activeflows:IDS, mergeid:ID): Nat is
     var incf:IDS, active_merge:Nat in
        incf := find_incf(p, mergeid);
        active_merge := find_active_tokens(activeflows, incf);
        return active_merge
    end var
end function

function find_incf(p: BPROCESS, mergeid:ID): IDS is 
	case p in
	var name: ID, nodes: NODES, flows: FLOWS in
           proc (name, nodes, flows) -> return find_incf_nodes(nodes, mergeid)
        end case
end function

function find_incf_nodes (nodes: NODES, mergeid: ID): IDS is 
	case nodes in
	var gateways: GATEWAYS, initial: INITIAL, finals: FINALS, tasks: TASKS, tl: NODES in
           cons(g(gateways), tl) -> return find_incf_gateways(gateways, mergeid)
	|  cons(i(initial), tl) 
	|  cons(f(finals), tl) 
	|  cons(t(tasks), tl)    -> return find_incf_nodes(tl, mergeid)
        |  nil -> return nil
        end case
end function

function find_incf_gateways (gateways: GATEWAYS, mergeid: ID): IDS is 
	case gateways in
	var ident: ID, pattern: GPATTERN, sort: GSORT, incf: IDS, outf: IDS, tl: GATEWAYS in
           cons(gateway(ident, pattern, sort, incf, outf), tl) -> 
	   		   if (ident==mergeid) then 
			      return incf
			   else
			      return find_incf_gateways(tl,mergeid)
			   end if
        |  nil -> return nil
        end case
end function

function find_active_tokens(activeflows:IDS, incf:IDS): Nat is 
    var tokens:IDS, count:Nat in
        tokens := inter(activeflows, incf);
        count := length(tokens);
        return count 
    end var
end function

end module
